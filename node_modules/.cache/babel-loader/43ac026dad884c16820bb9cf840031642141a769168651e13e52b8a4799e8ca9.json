{"ast":null,"code":"// Chat service using WebRTC for true cross-browser/device communication\n// Works across different browsers and devices without backend\n\nclass ChatService {\n  constructor() {\n    this.messages = [];\n    this.currentUser = null;\n    this.messageListeners = [];\n    this.userListeners = [];\n    this.activeUsers = new Set();\n    this.peers = new Map(); // Map of peerId -> RTCPeerConnection\n    this.dataChannels = new Map(); // Map of peerId -> RTCDataChannel\n    this.sessionId = Date.now() + Math.random().toString(36);\n\n    // Simple signaling using localStorage (for initial discovery)\n    this.signalingKey = 'chatapp_signaling';\n    this.heartbeatKey = 'chatapp_heartbeat';\n    this.pollInterval = null;\n\n    // Listen for storage events for signaling\n    window.addEventListener('storage', e => {\n      if (e.key === this.signalingKey) {\n        this.handleSignalingMessage(e.newValue);\n      }\n    });\n\n    // Cleanup when page unloads\n    window.addEventListener('beforeunload', () => {\n      this.cleanup();\n    });\n\n    // Start discovery and heartbeat\n    this.startDiscovery();\n  }\n\n  // Start peer discovery process\n  startDiscovery() {\n    // Send periodic heartbeats and check for new peers\n    this.pollInterval = setInterval(() => {\n      this.sendHeartbeat();\n      this.discoverPeers();\n      this.cleanupInactivePeers();\n    }, 2000);\n\n    // Initial discovery\n    this.discoverPeers();\n  }\n\n  // Send heartbeat to announce our presence\n  sendHeartbeat() {\n    if (!this.currentUser) return;\n    try {\n      const heartbeats = JSON.parse(localStorage.getItem(this.heartbeatKey) || '{}');\n      heartbeats[this.sessionId] = {\n        username: this.currentUser,\n        timestamp: Date.now()\n      };\n      localStorage.setItem(this.heartbeatKey, JSON.stringify(heartbeats));\n    } catch (error) {\n      console.error('Error sending heartbeat:', error);\n    }\n  }\n\n  // Discover new peers from heartbeats\n  discoverPeers() {\n    try {\n      const heartbeats = JSON.parse(localStorage.getItem(this.heartbeatKey) || '{}');\n      const now = Date.now();\n      const activeUsers = new Set();\n      Object.entries(heartbeats).forEach(([sessionId, data]) => {\n        // Skip our own session and inactive users\n        if (sessionId === this.sessionId || now - data.timestamp > 10000) {\n          return;\n        }\n        activeUsers.add(data.username);\n\n        // If we don't have a connection to this peer, initiate one\n        if (!this.peers.has(sessionId)) {\n          this.createPeerConnection(sessionId, true); // true = we are the initiator\n        }\n      });\n\n      // Update active users\n      this.activeUsers = activeUsers;\n      if (this.currentUser) {\n        this.activeUsers.add(this.currentUser);\n      }\n      this.notifyUserListeners();\n    } catch (error) {\n      console.error('Error discovering peers:', error);\n    }\n  }\n\n  // Clean up inactive peers\n  cleanupInactivePeers() {\n    try {\n      const heartbeats = JSON.parse(localStorage.getItem(this.heartbeatKey) || '{}');\n      const now = Date.now();\n\n      // Remove old heartbeats and close connections\n      Object.entries(heartbeats).forEach(([sessionId, data]) => {\n        if (now - data.timestamp > 10000) {\n          delete heartbeats[sessionId];\n\n          // Close peer connection if exists\n          if (this.peers.has(sessionId)) {\n            this.peers.get(sessionId).close();\n            this.peers.delete(sessionId);\n            this.dataChannels.delete(sessionId);\n          }\n        }\n      });\n      localStorage.setItem(this.heartbeatKey, JSON.stringify(heartbeats));\n    } catch (error) {\n      console.error('Error cleaning up peers:', error);\n    }\n  }\n\n  // Create WebRTC peer connection\n  createPeerConnection(peerId, isInitiator) {\n    try {\n      const config = {\n        iceServers: [{\n          urls: 'stun:stun.l.google.com:19302'\n        }, {\n          urls: 'stun:stun1.l.google.com:19302'\n        }]\n      };\n      const peerConnection = new RTCPeerConnection(config);\n      this.peers.set(peerId, peerConnection);\n\n      // Create data channel for messages\n      if (isInitiator) {\n        const dataChannel = peerConnection.createDataChannel('chat', {\n          ordered: true\n        });\n        this.setupDataChannel(dataChannel, peerId);\n      } else {\n        peerConnection.ondatachannel = event => {\n          this.setupDataChannel(event.channel, peerId);\n        };\n      }\n\n      // Handle ICE candidates\n      peerConnection.onicecandidate = event => {\n        if (event.candidate) {\n          this.sendSignalingMessage({\n            type: 'ice-candidate',\n            candidate: event.candidate,\n            targetPeer: peerId,\n            fromPeer: this.sessionId\n          });\n        }\n      };\n\n      // Start connection process if initiator\n      if (isInitiator) {\n        peerConnection.createOffer().then(offer => {\n          return peerConnection.setLocalDescription(offer);\n        }).then(() => {\n          this.sendSignalingMessage({\n            type: 'offer',\n            offer: peerConnection.localDescription,\n            targetPeer: peerId,\n            fromPeer: this.sessionId\n          });\n        }).catch(error => {\n          console.error('Error creating offer:', error);\n        });\n      }\n    } catch (error) {\n      console.error('Error creating peer connection:', error);\n    }\n  }\n\n  // Setup data channel for messaging\n  setupDataChannel(dataChannel, peerId) {\n    this.dataChannels.set(peerId, dataChannel);\n    dataChannel.onopen = () => {\n      console.log(`Data channel opened with peer ${peerId}`);\n      // Send our message history to new peer\n      this.sendToPeer(peerId, {\n        type: 'MESSAGE_HISTORY',\n        messages: this.messages\n      });\n    };\n    dataChannel.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        this.handlePeerMessage(data, peerId);\n      } catch (error) {\n        console.error('Error handling peer message:', error);\n      }\n    };\n    dataChannel.onclose = () => {\n      console.log(`Data channel closed with peer ${peerId}`);\n      this.dataChannels.delete(peerId);\n    };\n  }\n\n  // Handle messages from peers\n  handlePeerMessage(data, fromPeer) {\n    switch (data.type) {\n      case 'NEW_MESSAGE':\n        // Add message if we don't already have it\n        if (!this.messages.find(m => m.id === data.message.id)) {\n          this.messages.push(data.message);\n          this.messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));\n          this.notifyMessageListeners();\n\n          // Forward to other peers\n          this.broadcastToPeers(data, fromPeer);\n        }\n        break;\n      case 'MESSAGE_HISTORY':\n        // Merge message histories\n        data.messages.forEach(msg => {\n          if (!this.messages.find(m => m.id === msg.id)) {\n            this.messages.push(msg);\n          }\n        });\n        this.messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));\n        this.notifyMessageListeners();\n        break;\n      case 'CLEAR_CHAT':\n        this.messages = [];\n        this.notifyMessageListeners();\n        // Forward to other peers\n        this.broadcastToPeers(data, fromPeer);\n        break;\n      default:\n        break;\n    }\n  }\n\n  // Send message to specific peer\n  sendToPeer(peerId, data) {\n    const dataChannel = this.dataChannels.get(peerId);\n    if (dataChannel && dataChannel.readyState === 'open') {\n      try {\n        dataChannel.send(JSON.stringify(data));\n      } catch (error) {\n        console.error(`Error sending to peer ${peerId}:`, error);\n      }\n    }\n  }\n\n  // Broadcast message to all connected peers\n  broadcastToPeers(data, excludePeer = null) {\n    this.dataChannels.forEach((dataChannel, peerId) => {\n      if (peerId !== excludePeer && dataChannel.readyState === 'open') {\n        try {\n          dataChannel.send(JSON.stringify(data));\n        } catch (error) {\n          console.error(`Error broadcasting to peer ${peerId}:`, error);\n        }\n      }\n    });\n  }\n\n  // Send signaling message via localStorage\n  sendSignalingMessage(message) {\n    try {\n      const signaling = JSON.parse(localStorage.getItem(this.signalingKey) || '[]');\n      signaling.push({\n        ...message,\n        timestamp: Date.now()\n      });\n\n      // Keep only recent signaling messages (last 50)\n      if (signaling.length > 50) {\n        signaling.splice(0, signaling.length - 50);\n      }\n      localStorage.setItem(this.signalingKey, JSON.stringify(signaling));\n    } catch (error) {\n      console.error('Error sending signaling message:', error);\n    }\n  }\n\n  // Handle signaling messages\n  handleSignalingMessage(newValue) {\n    if (!newValue) return;\n    try {\n      const messages = JSON.parse(newValue);\n      const recentMessages = messages.filter(msg => msg.targetPeer === this.sessionId && Date.now() - msg.timestamp < 30000 // Only process recent messages\n      );\n      recentMessages.forEach(msg => {\n        this.processSignalingMessage(msg);\n      });\n    } catch (error) {\n      console.error('Error handling signaling message:', error);\n    }\n  }\n\n  // Process individual signaling message\n  processSignalingMessage(message) {\n    const {\n      type,\n      fromPeer\n    } = message;\n    let peerConnection = this.peers.get(fromPeer);\n    try {\n      switch (type) {\n        case 'offer':\n          if (!peerConnection) {\n            peerConnection = this.createPeerConnection(fromPeer, false);\n          }\n          peerConnection.setRemoteDescription(new RTCSessionDescription(message.offer)).then(() => peerConnection.createAnswer()).then(answer => peerConnection.setLocalDescription(answer)).then(() => {\n            this.sendSignalingMessage({\n              type: 'answer',\n              answer: peerConnection.localDescription,\n              targetPeer: fromPeer,\n              fromPeer: this.sessionId\n            });\n          });\n          break;\n        case 'answer':\n          if (peerConnection) {\n            peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer));\n          }\n          break;\n        case 'ice-candidate':\n          if (peerConnection) {\n            peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));\n          }\n          break;\n        default:\n          break;\n      }\n    } catch (error) {\n      console.error('Error processing signaling message:', error);\n    }\n  }\n\n  // Set current user\n  setCurrentUser(username) {\n    if (this.currentUser) {\n      this.activeUsers.delete(this.currentUser);\n    }\n    if (username) {\n      this.currentUser = username;\n      this.activeUsers.add(username);\n    } else {\n      this.currentUser = null;\n    }\n    this.notifyUserListeners();\n  }\n\n  // Send a message\n  sendMessage(text) {\n    if (!this.currentUser || !text.trim()) return;\n    const message = {\n      id: Date.now() + Math.random(),\n      text: text.trim(),\n      sender: this.currentUser,\n      timestamp: new Date().toISOString()\n    };\n\n    // Add to local messages\n    this.messages.push(message);\n    this.notifyMessageListeners();\n\n    // Broadcast to all peers\n    this.broadcastToPeers({\n      type: 'NEW_MESSAGE',\n      message\n    });\n  }\n\n  // Get all messages\n  getMessages() {\n    return [...this.messages];\n  }\n\n  // Get active users\n  getActiveUsers() {\n    return Array.from(this.activeUsers);\n  }\n\n  // Clear all messages\n  clearChat() {\n    this.messages = [];\n    this.notifyMessageListeners();\n\n    // Broadcast clear to all peers\n    this.broadcastToPeers({\n      type: 'CLEAR_CHAT'\n    });\n  }\n\n  // Add message listener\n  onMessage(callback) {\n    this.messageListeners.push(callback);\n    return () => {\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  // Add user listener\n  onUsersChange(callback) {\n    this.userListeners.push(callback);\n    return () => {\n      this.userListeners = this.userListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  // Notify message listeners\n  notifyMessageListeners() {\n    this.messageListeners.forEach(callback => {\n      try {\n        callback(this.messages);\n      } catch (error) {\n        console.error('Message listener error:', error);\n      }\n    });\n  }\n\n  // Notify user listeners\n  notifyUserListeners() {\n    this.userListeners.forEach(callback => {\n      try {\n        callback(Array.from(this.activeUsers));\n      } catch (error) {\n        console.error('User listener error:', error);\n      }\n    });\n  }\n\n  // Cleanup when leaving\n  cleanup() {\n    // Close all peer connections\n    this.peers.forEach(peer => {\n      try {\n        peer.close();\n      } catch (error) {\n        console.error('Error closing peer connection:', error);\n      }\n    });\n    this.peers.clear();\n    this.dataChannels.clear();\n    if (this.pollInterval) {\n      clearInterval(this.pollInterval);\n    }\n\n    // Remove our heartbeat\n    try {\n      const heartbeats = JSON.parse(localStorage.getItem(this.heartbeatKey) || '{}');\n      delete heartbeats[this.sessionId];\n      localStorage.setItem(this.heartbeatKey, JSON.stringify(heartbeats));\n    } catch (error) {\n      console.error('Error cleaning up heartbeat:', error);\n    }\n  }\n}\n\n// Create singleton instance\nconst chatService = new ChatService();\nexport default chatService;","map":{"version":3,"names":["ChatService","constructor","messages","currentUser","messageListeners","userListeners","activeUsers","Set","peers","Map","dataChannels","sessionId","Date","now","Math","random","toString","signalingKey","heartbeatKey","pollInterval","window","addEventListener","e","key","handleSignalingMessage","newValue","cleanup","startDiscovery","setInterval","sendHeartbeat","discoverPeers","cleanupInactivePeers","heartbeats","JSON","parse","localStorage","getItem","username","timestamp","setItem","stringify","error","console","Object","entries","forEach","data","add","has","createPeerConnection","notifyUserListeners","get","close","delete","peerId","isInitiator","config","iceServers","urls","peerConnection","RTCPeerConnection","set","dataChannel","createDataChannel","ordered","setupDataChannel","ondatachannel","event","channel","onicecandidate","candidate","sendSignalingMessage","type","targetPeer","fromPeer","createOffer","then","offer","setLocalDescription","localDescription","catch","onopen","log","sendToPeer","onmessage","handlePeerMessage","onclose","find","m","id","message","push","sort","a","b","notifyMessageListeners","broadcastToPeers","msg","readyState","send","excludePeer","signaling","length","splice","recentMessages","filter","processSignalingMessage","setRemoteDescription","RTCSessionDescription","createAnswer","answer","addIceCandidate","RTCIceCandidate","setCurrentUser","sendMessage","text","trim","sender","toISOString","getMessages","getActiveUsers","Array","from","clearChat","onMessage","callback","cb","onUsersChange","peer","clear","clearInterval","chatService"],"sources":["/home/niroj/Desktop/chatapp/src/utils/chatService.js"],"sourcesContent":["// Chat service using WebRTC for true cross-browser/device communication\n// Works across different browsers and devices without backend\n\nclass ChatService {\n  constructor() {\n    this.messages = [];\n    this.currentUser = null;\n    this.messageListeners = [];\n    this.userListeners = [];\n    this.activeUsers = new Set();\n    this.peers = new Map(); // Map of peerId -> RTCPeerConnection\n    this.dataChannels = new Map(); // Map of peerId -> RTCDataChannel\n    this.sessionId = Date.now() + Math.random().toString(36);\n    \n    // Simple signaling using localStorage (for initial discovery)\n    this.signalingKey = 'chatapp_signaling';\n    this.heartbeatKey = 'chatapp_heartbeat';\n    this.pollInterval = null;\n    \n    // Listen for storage events for signaling\n    window.addEventListener('storage', (e) => {\n      if (e.key === this.signalingKey) {\n        this.handleSignalingMessage(e.newValue);\n      }\n    });\n\n    // Cleanup when page unloads\n    window.addEventListener('beforeunload', () => {\n      this.cleanup();\n    });\n\n    // Start discovery and heartbeat\n    this.startDiscovery();\n  }\n\n  // Start peer discovery process\n  startDiscovery() {\n    // Send periodic heartbeats and check for new peers\n    this.pollInterval = setInterval(() => {\n      this.sendHeartbeat();\n      this.discoverPeers();\n      this.cleanupInactivePeers();\n    }, 2000);\n\n    // Initial discovery\n    this.discoverPeers();\n  }\n\n  // Send heartbeat to announce our presence\n  sendHeartbeat() {\n    if (!this.currentUser) return;\n\n    try {\n      const heartbeats = JSON.parse(localStorage.getItem(this.heartbeatKey) || '{}');\n      heartbeats[this.sessionId] = {\n        username: this.currentUser,\n        timestamp: Date.now()\n      };\n      localStorage.setItem(this.heartbeatKey, JSON.stringify(heartbeats));\n    } catch (error) {\n      console.error('Error sending heartbeat:', error);\n    }\n  }\n\n  // Discover new peers from heartbeats\n  discoverPeers() {\n    try {\n      const heartbeats = JSON.parse(localStorage.getItem(this.heartbeatKey) || '{}');\n      const now = Date.now();\n      const activeUsers = new Set();\n\n      Object.entries(heartbeats).forEach(([sessionId, data]) => {\n        // Skip our own session and inactive users\n        if (sessionId === this.sessionId || now - data.timestamp > 10000) {\n          return;\n        }\n\n        activeUsers.add(data.username);\n\n        // If we don't have a connection to this peer, initiate one\n        if (!this.peers.has(sessionId)) {\n          this.createPeerConnection(sessionId, true); // true = we are the initiator\n        }\n      });\n\n      // Update active users\n      this.activeUsers = activeUsers;\n      if (this.currentUser) {\n        this.activeUsers.add(this.currentUser);\n      }\n      this.notifyUserListeners();\n    } catch (error) {\n      console.error('Error discovering peers:', error);\n    }\n  }\n\n  // Clean up inactive peers\n  cleanupInactivePeers() {\n    try {\n      const heartbeats = JSON.parse(localStorage.getItem(this.heartbeatKey) || '{}');\n      const now = Date.now();\n\n      // Remove old heartbeats and close connections\n      Object.entries(heartbeats).forEach(([sessionId, data]) => {\n        if (now - data.timestamp > 10000) {\n          delete heartbeats[sessionId];\n          \n          // Close peer connection if exists\n          if (this.peers.has(sessionId)) {\n            this.peers.get(sessionId).close();\n            this.peers.delete(sessionId);\n            this.dataChannels.delete(sessionId);\n          }\n        }\n      });\n\n      localStorage.setItem(this.heartbeatKey, JSON.stringify(heartbeats));\n    } catch (error) {\n      console.error('Error cleaning up peers:', error);\n    }\n  }\n\n  // Create WebRTC peer connection\n  createPeerConnection(peerId, isInitiator) {\n    try {\n      const config = {\n        iceServers: [\n          { urls: 'stun:stun.l.google.com:19302' },\n          { urls: 'stun:stun1.l.google.com:19302' }\n        ]\n      };\n\n      const peerConnection = new RTCPeerConnection(config);\n      this.peers.set(peerId, peerConnection);\n\n      // Create data channel for messages\n      if (isInitiator) {\n        const dataChannel = peerConnection.createDataChannel('chat', {\n          ordered: true\n        });\n        this.setupDataChannel(dataChannel, peerId);\n      } else {\n        peerConnection.ondatachannel = (event) => {\n          this.setupDataChannel(event.channel, peerId);\n        };\n      }\n\n      // Handle ICE candidates\n      peerConnection.onicecandidate = (event) => {\n        if (event.candidate) {\n          this.sendSignalingMessage({\n            type: 'ice-candidate',\n            candidate: event.candidate,\n            targetPeer: peerId,\n            fromPeer: this.sessionId\n          });\n        }\n      };\n\n      // Start connection process if initiator\n      if (isInitiator) {\n        peerConnection.createOffer()\n          .then(offer => {\n            return peerConnection.setLocalDescription(offer);\n          })\n          .then(() => {\n            this.sendSignalingMessage({\n              type: 'offer',\n              offer: peerConnection.localDescription,\n              targetPeer: peerId,\n              fromPeer: this.sessionId\n            });\n          })\n          .catch(error => {\n            console.error('Error creating offer:', error);\n          });\n      }\n    } catch (error) {\n      console.error('Error creating peer connection:', error);\n    }\n  }\n\n  // Setup data channel for messaging\n  setupDataChannel(dataChannel, peerId) {\n    this.dataChannels.set(peerId, dataChannel);\n\n    dataChannel.onopen = () => {\n      console.log(`Data channel opened with peer ${peerId}`);\n      // Send our message history to new peer\n      this.sendToPeer(peerId, {\n        type: 'MESSAGE_HISTORY',\n        messages: this.messages\n      });\n    };\n\n    dataChannel.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        this.handlePeerMessage(data, peerId);\n      } catch (error) {\n        console.error('Error handling peer message:', error);\n      }\n    };\n\n    dataChannel.onclose = () => {\n      console.log(`Data channel closed with peer ${peerId}`);\n      this.dataChannels.delete(peerId);\n    };\n  }\n\n  // Handle messages from peers\n  handlePeerMessage(data, fromPeer) {\n    switch (data.type) {\n      case 'NEW_MESSAGE':\n        // Add message if we don't already have it\n        if (!this.messages.find(m => m.id === data.message.id)) {\n          this.messages.push(data.message);\n          this.messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));\n          this.notifyMessageListeners();\n          \n          // Forward to other peers\n          this.broadcastToPeers(data, fromPeer);\n        }\n        break;\n        \n      case 'MESSAGE_HISTORY':\n        // Merge message histories\n        data.messages.forEach(msg => {\n          if (!this.messages.find(m => m.id === msg.id)) {\n            this.messages.push(msg);\n          }\n        });\n        this.messages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));\n        this.notifyMessageListeners();\n        break;\n        \n      case 'CLEAR_CHAT':\n        this.messages = [];\n        this.notifyMessageListeners();\n        // Forward to other peers\n        this.broadcastToPeers(data, fromPeer);\n        break;\n        \n      default:\n        break;\n    }\n  }\n\n  // Send message to specific peer\n  sendToPeer(peerId, data) {\n    const dataChannel = this.dataChannels.get(peerId);\n    if (dataChannel && dataChannel.readyState === 'open') {\n      try {\n        dataChannel.send(JSON.stringify(data));\n      } catch (error) {\n        console.error(`Error sending to peer ${peerId}:`, error);\n      }\n    }\n  }\n\n  // Broadcast message to all connected peers\n  broadcastToPeers(data, excludePeer = null) {\n    this.dataChannels.forEach((dataChannel, peerId) => {\n      if (peerId !== excludePeer && dataChannel.readyState === 'open') {\n        try {\n          dataChannel.send(JSON.stringify(data));\n        } catch (error) {\n          console.error(`Error broadcasting to peer ${peerId}:`, error);\n        }\n      }\n    });\n  }\n\n  // Send signaling message via localStorage\n  sendSignalingMessage(message) {\n    try {\n      const signaling = JSON.parse(localStorage.getItem(this.signalingKey) || '[]');\n      signaling.push({\n        ...message,\n        timestamp: Date.now()\n      });\n      \n      // Keep only recent signaling messages (last 50)\n      if (signaling.length > 50) {\n        signaling.splice(0, signaling.length - 50);\n      }\n      \n      localStorage.setItem(this.signalingKey, JSON.stringify(signaling));\n    } catch (error) {\n      console.error('Error sending signaling message:', error);\n    }\n  }\n\n  // Handle signaling messages\n  handleSignalingMessage(newValue) {\n    if (!newValue) return;\n\n    try {\n      const messages = JSON.parse(newValue);\n      const recentMessages = messages.filter(msg => \n        msg.targetPeer === this.sessionId && \n        Date.now() - msg.timestamp < 30000 // Only process recent messages\n      );\n\n      recentMessages.forEach(msg => {\n        this.processSignalingMessage(msg);\n      });\n    } catch (error) {\n      console.error('Error handling signaling message:', error);\n    }\n  }\n\n  // Process individual signaling message\n  processSignalingMessage(message) {\n    const { type, fromPeer } = message;\n    let peerConnection = this.peers.get(fromPeer);\n\n    try {\n      switch (type) {\n        case 'offer':\n          if (!peerConnection) {\n            peerConnection = this.createPeerConnection(fromPeer, false);\n          }\n          \n          peerConnection.setRemoteDescription(new RTCSessionDescription(message.offer))\n            .then(() => peerConnection.createAnswer())\n            .then(answer => peerConnection.setLocalDescription(answer))\n            .then(() => {\n              this.sendSignalingMessage({\n                type: 'answer',\n                answer: peerConnection.localDescription,\n                targetPeer: fromPeer,\n                fromPeer: this.sessionId\n              });\n            });\n          break;\n\n        case 'answer':\n          if (peerConnection) {\n            peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer));\n          }\n          break;\n\n        case 'ice-candidate':\n          if (peerConnection) {\n            peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));\n          }\n          break;\n\n        default:\n          break;\n      }\n    } catch (error) {\n      console.error('Error processing signaling message:', error);\n    }\n  }\n\n  // Set current user\n  setCurrentUser(username) {\n    if (this.currentUser) {\n      this.activeUsers.delete(this.currentUser);\n    }\n    \n    if (username) {\n      this.currentUser = username;\n      this.activeUsers.add(username);\n    } else {\n      this.currentUser = null;\n    }\n    \n    this.notifyUserListeners();\n  }\n\n  // Send a message\n  sendMessage(text) {\n    if (!this.currentUser || !text.trim()) return;\n\n    const message = {\n      id: Date.now() + Math.random(),\n      text: text.trim(),\n      sender: this.currentUser,\n      timestamp: new Date().toISOString()\n    };\n\n    // Add to local messages\n    this.messages.push(message);\n    this.notifyMessageListeners();\n\n    // Broadcast to all peers\n    this.broadcastToPeers({\n      type: 'NEW_MESSAGE',\n      message\n    });\n  }\n\n  // Get all messages\n  getMessages() {\n    return [...this.messages];\n  }\n\n  // Get active users\n  getActiveUsers() {\n    return Array.from(this.activeUsers);\n  }\n\n  // Clear all messages\n  clearChat() {\n    this.messages = [];\n    this.notifyMessageListeners();\n    \n    // Broadcast clear to all peers\n    this.broadcastToPeers({\n      type: 'CLEAR_CHAT'\n    });\n  }\n\n  // Add message listener\n  onMessage(callback) {\n    this.messageListeners.push(callback);\n    return () => {\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  // Add user listener\n  onUsersChange(callback) {\n    this.userListeners.push(callback);\n    return () => {\n      this.userListeners = this.userListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  // Notify message listeners\n  notifyMessageListeners() {\n    this.messageListeners.forEach(callback => {\n      try {\n        callback(this.messages);\n      } catch (error) {\n        console.error('Message listener error:', error);\n      }\n    });\n  }\n\n  // Notify user listeners\n  notifyUserListeners() {\n    this.userListeners.forEach(callback => {\n      try {\n        callback(Array.from(this.activeUsers));\n      } catch (error) {\n        console.error('User listener error:', error);\n      }\n    });\n  }\n\n  // Cleanup when leaving\n  cleanup() {\n    // Close all peer connections\n    this.peers.forEach(peer => {\n      try {\n        peer.close();\n      } catch (error) {\n        console.error('Error closing peer connection:', error);\n      }\n    });\n    \n    this.peers.clear();\n    this.dataChannels.clear();\n    \n    if (this.pollInterval) {\n      clearInterval(this.pollInterval);\n    }\n\n    // Remove our heartbeat\n    try {\n      const heartbeats = JSON.parse(localStorage.getItem(this.heartbeatKey) || '{}');\n      delete heartbeats[this.sessionId];\n      localStorage.setItem(this.heartbeatKey, JSON.stringify(heartbeats));\n    } catch (error) {\n      console.error('Error cleaning up heartbeat:', error);\n    }\n  }\n}\n\n// Create singleton instance\nconst chatService = new ChatService();\n\nexport default chatService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}